import matplotlib.pyplot as plt
import scipy.io.wavfile as wv
import sounddevice as sd
import numpy as np
import math


def make_recording(freq, t, name):
    print("Recording...")
    s = sd.rec(int(t * freq),
               blocking=True,
               dtype='int16')
    print("Stopped recording.")
    print("Playing back recording...")
    sd.play(s, blocking=True)
    print("Playback finished.")
    # save as .wav file
    save_wav(name, s, freq)


def save_wav(filename, recording, fs):
    print("Recording saved as \"" + filename + "\".")
    wv.write(filename, fs, recording)


# The "make_window" function takes a window width parameter and returns
# an array representing the Hamming window
def make_window(w, freq):
    sample_size = int(freq*w / 1000)
    ham = []
    for n in range(0, sample_size):
        ham.append(0.54 - 0.46 * math.cos(2 * math.pi * n / sample_size))
    plt.plot(ham)
    plt.show()
    return ham


def make_mel_banks(min, max, bins, nfft, fs):
    mel_min = 1127 * math.log1p(1 + min / 700)
    mel_max = 1127 * math.log1p(1 + max / 700)
    mel_banks = [float(min)]
    for i in range(1, bins+2):
        mel_banks.append(i * (mel_max-mel_min)/bins)
    # inverse mel
    count = 0
    for i in mel_banks:
        value = 700 * (np.exp(i / 1125) - 1)
        rounded = math.floor((nfft+1) * value / fs)
        mel_banks[count] = 700 * (np.exp(i/1125) - 1)
        count += 1
    # plt.scatter(mel_banks, range(0, bins+2))
    # plt.show()
    return mel_banks


def make_triangle(min, max, id, size):
    triangle = []
    for i in range(0, min):
        triangle.append(0)
    mid = (max+min) / 2
    for i in range(min, mid):
        id = len(triangle)
        triangle.append((id-min)/(mid-min))
    for i in range(mid, max):
        id = len(triangle)
        triangle.append((max-id)/(max-mid))
    for i in range(max, size):
        triangle.append(0)
    plt.scatter(triangle, range(0, size))
	plt.show()
	return triangle

	
def mat_multiply(a, b):
    sum = 0
	for i in range(0, len(a)):
	    sum += a[i] * b[i]
	return sum

	
def mel_filter(data, banks, order):
    bins = len(banks) - 2
	filtered = []
	for i in range(0, banks):
        lo = banks[i]
        hi = banks[i + 1]
        tri = make_triangle(lo, hi, i, len(data))
		coefficient = mat_multiply(data, tri)
		filtered.append(coefficient)
    # 4) take log of result
	for i in range(0, len(filtered)):
	    filtered[i] = math.log10(filtered[i])
	return filtered
	
	
# have a windowed array of data points now
def get_vector(array, fs):
    plt.plot(array)
    plt.title('Windowed signal')
    plt.show()

    # 1) compute FFT- Make FFT length= to next power of 2 above window length
    my_pad = int(np.power(2, 0 + np.ceil(np.log2(len(array)))))
    out = np.fft.fft(array, my_pad)
    plt.plot(out)
    plt.title('FFT of signal')
    plt.show()

    # 2) take magnitude of FFT (throw away phase)
    out = abs(out)
    plt.plot(out)
    plt.title('|FFT of signal|')
    plt.show()

    # create mel banks
    min = 0
    max = 8000
    bins = 23
    mels = make_mel_banks(min, max, bins, my_pad, fs)

    # 3) v1 compute mel filter warped spectra
    # take half of array
    tmp = len(out)/2 + 1
    tmp = out[0:int(tmp)]
	
    # 5) take IDFT / DCT
    out = np.fft.ifft(mel_filter(tmp, mels))
	
	# 6) retain first 13 coefficients
	return out[0:12]


def produce_mfcc(signal, window, fs, fr, max):
    # have a window function
    # want to apply window to signal
    # perform cepstrum operations to windowed signal
    # repeat with window shifted
    window_length = len(window)
    signal_length = len(signal)
    shift = 1/fr * fs

    mfcc = []
    i = 0
    count = 0
    while i + window_length <= signal_length:
        # Get truncated sample and multiply with window function
        start = int(i)
        end = int(i + window_length)
        tmp = signal[start:end]
        tmp = np.multiply(tmp, window)
        if count == 280:
            plt.plot(tmp)
            plt.show()
            get_vector(tmp, fs, max)
        # mfcc.append(get_vector(tmp))
        i += shift
        count += 1
	return mfcc


def get_delta(data, diameter, max):
    length = len(data)
	d = np.zeros(max, length)
	for i in range(0, max):
	    for j in range(0, length):
		    if j >= diameter and j < length-diameter:
				num = 0
				den = 0
				for k in range(-diameter, diameter+1):    
					num += k * data[i][j+k]
					den += k * k
				d[i][j] = num / den
			else:
			    d[i][j] = 0
	return d
	
	
# =============#
#     START    #
# -------------#
# Problem 3(a).
# Reading over MFCCs (5 points)
# Look back over the lectures and re-read precisely how MFCCs are computed.
# You’ll need to compute MFCCs using an FFT function, but you’ll also have
# to do the mel-warped frequency spectrum and the log magnitude as well.


# Problem 3(b).
# MFCC Specs (40 points)
# Write a function to take a speech utterance and compute MFCCs. You need
# only compute C0 through C12 (i.e., for each time t, you should produce
# a 13-dimensional 4 feature vector xt 2 RN with N = 13. Each time frame t
# should span a window of 25ms. Your frame rate should be 100Hz
# (i.e., a 10ms skip between frames, as is typical).

# record speech and save as .wav file
fs = 16000
time = 4
ch = 1
sd.default.samplerate = fs
sd.default.channels = ch
# filename = "prob3.wav"
filename = "HW2p4.wav"

# make_recording(fs, time, filename)
signal = wv.read(filename)

# compute MFCCs
data = signal[1]
# plt.plot(data)
# plt.title('Signal')
# plt.show()
window = 25
framerate = 100
maxC = 12
delta_diameter

hamming_window = make_window(window, fs)


# Problem 3(c). Recordings (20 points)
# Record and store as many as you can wavefiles of yourself saying the
# following single phrases: “Odessa”, “Turn on the lights”,
# “Turn off the lights”, “What time is it”, “Play music”, and “Stop music.”
# I.e., you have a six phrase vocabulary. Each wavefile should consist of
# a little bit of silence, the recording of the word, and then a bit of
# silence at the end. Make sure that the recording levels are good
# (i.e., the wavefiles should not be clipped, as that creates digital
# distortion) but also should not be too low either (as that also
# creates noise). Ideally, the peaks of the waveform should be about
# 3dB down from the maximum intensity.


# Problem 3(d).
# MFCCs (20 points)
# Compute MFCCs on each of your wavefiles and store them in separate matrices
# (the matrices will be 13 x T where T is the number of frames of speech.
mfcc = produce_mfcc(data, hamming_window, fs, framerate, maxC)

# Problem 3(e).
# Delta features (20 points)
# Once you have your matrix, compute delta features. Use a window size of M=2.
# Concatenate your feature matrix with your delta-feature matrix to create
# a feature matrix of dimension 26 x(T - 2M).
delta = get_delta(mfcc, delta_diameter, maxC)
features = []
for i in range(0, len(delta)):
    a1 = mfcc[:,i]
	a2 = delta[:,i]
	features.append(np.concatenate(a1, a2))

# Problem 3(f).
# Question (20 points)
# Why is your matrix of dimension 26 x (T - 2M)?


# Problem 3(g).
# Turn In (5 points)
# Turn in a plot of one waveform for each speech lexical item, and also a
# plot of the corresponding 26 x (T - 2M) matrix using the matlab function
# imagesc. This means that you will turn in 5 waveforms, and 5 matrices,
# one each for each word.
