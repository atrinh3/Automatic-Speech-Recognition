# load libraries
import sounddevice as sd
import scipy.io.wavfile
import numpy as np
import matplotlib.pyplot as plt

def make_recording(freq, time, name)
	CHANNELS = 1 # one channel, so mono not stereo
	s = sd.rec(int(duration * freq), 
			   samplerate=freq,
			   channels=CHANNELS)
	sd.wait()
	tmp = sd.playrec(s, fs, channels=CHANNELS)
	# save as .wav file
	save_wav(s, name)

	
def make_spectrogram(window, fft, npower, fs, row, id):	
	# Now produce a spectrogram.
	# First, set the window size, which is the number of samples
	# to process at a time over which each vertical column of the
	# spectrum corresponds to. The python specgram calls this NFFT for
	# some reason, but we’re going to name a parameter window_size, and this
	# is going to be in units of milliseconds, and we’ll convert it
	# to the corresponding ’nfft’ value.
	window_size = window
	next_power = npower
	nfft = fft
	
	my_pad = int(np.power(2,(next_power-1)+ np.ceil(np.log2(nfft))))

	# Note that my_pad is a power of 2, and this is what the final FFT length
	# python will use.

	# Next, we set how many points of the speech windows overlap between successive
	# windows. We’re going to say that 7/8’ths of the points overlap (so stepping
	# by 1/8th of a window at each column of the spectrogram. Note that
	# how many points this is depends on the window size.
	my_noverlap = int(float(nfft)*7.0/8.0)

	# Lastly, we’re going to select a color map. ’jet’ has commonly been used
	# in matlab, but there is some concern about using ’jet’ as a color map as
	# the color intensity (or luminosity) is dark for both low and high magnitude
	# values (so it doesn’t plot well when plotted in B&W). Hence, we’re going
	# to use the colormap called ’cubehelix’, although if you change this to
	# use ’jet’, you’ll see results that probably look more familiar since ’jet’
	# is so widely used when plotting in color.
	my_cmap = plt.get_cmap(’cubehelix’)

	# Lastly, plot the spectrogram.
	fig, ax = plt.subplot(row, nopwer, id)
	ax.set_title(’A spectrogram’)
	ax.set_xlabel(’time (seconds)’)
	ax.set_ylabel(’frequency’)
	Pxx, freqs, bins, im = plt.specgram(
	    s[:,0],
        NFFT=nfft,
		Fs=fs,
		pad_to=my_pad,
	    noverlap=my_noverlap,
		cmap=my_cmap);
	fig.colorbar(im).set_label(’Intensity (dB)’);
	plt.show()

def prob_1_a(w, name, fs, row):
    window = w
	next_power = npower
	fft = int(float(fs)*float(w)/1000.0)
	for i in range(1,5):
	    make_spectrogram(w, fft, i, fs, row, (row-1)*4 + i)

	
#=============#
#    START    #
#-------------#
fs = 16000 # 16kHz sample rate
duration = 4 # 4 seconds
filename = "prob1a.wav"

make_recording(fs, duration, filename)
prob_1_a(5, filename, fs, 1)
prob_1_a(10, filename, fs, 2)
prob_1_a(25, filename, fs, 3)
prob_1_a(50, filename, fs, 4)
prob_1_a(100, filename, fs, 5)
	
# Prob 1a
# try window sizes 5, 10, 25, 50, 100 (ms)
# for each window size, use increasing power of 2 for FFT size
# should have 20 spectrograms at the end

# window size 5 = 80 samples
	# FFT 1 = 128
	# FFT 2 = 256
	# FFT 3 = 512
	# FFT 4	= 1024
	
# window size 10 = 160 samples
	# FFT 1 = 256
	# FFT 2 = 512
	# FFT 3 = 1024
	# FFT 4 = 2048

# window size 25 = 400 samples
	# FFT 1 = 512
	# FFT 2 = 1024 
	# FFT 3 = 2048
	# FFT 4 = 4096

# window size 50 = 800 samples
	# FFT 1 = 1024
	# FFT 2 = 2048
	# FFT 3 = 4096
	# FFT 4 = 8192

# window size 100 = 1600 samples
	# FFT 1 = 2048
	# FFT 2 = 4096
	# FFT 3 = 8192
	# FFT 4 = 16384
